/* $Id$ */
CREATE OR REPLACE 
    PACKAGE BODY sp_pc_ges_debord_pkg AS

/* 
****************************************************************************
* sp_pc_ges_deb_to_tab - 
*/
-- DESCRIPTION :
-- -------------
-- Package de  gestion du mode débord
--
-- PARAMETRES :
-- ------------
--  xxx
--
-- HISTORIQUE DES MODIFICATIONS :
-- -------------------------------------------------------------------------
-- Ver,Date    ,Auteur  Description
-- -------------------------------------------------------------------------
-- 
-- 01a,29.09.14,TJAF    Création
-- 00a,20.05.13,GENPRG  version 2.13
-- -------------------------------------------------------------------------
--
-- RETOUR :
-- --------
--   ROWTYPE?
--
-- COMMIT :
-- --------
--   NON

-- DESCRIPTION :
-- -------------
-- Cette fonction permet l'affichage de la courbe des preparations
-- 2 cas a prendre en compte dans le calcul, commandes avant préordo (pas de palette) et apres avec palettes
FUNCTION sp_pc_gph_deb_to_tab (p_cod_usn    su_usn.cod_usn%TYPE,
                               p_dat_deb    DATE, 
                               p_dat_fin    DATE)
     RETURN tt_sp_pc_gph_deb  PIPELINED
IS
    v_version           su_ano_his.version%TYPE := '@(#) VERSION 01a $Revision$';
    v_nom_obj           su_ano_his.nom_obj%TYPE := 'sp_pc_gph_prep_deb_to_tab';
    v_etape             su_ano_his.txt_ano%TYPE := 'Declare';
    v_cod_err_su_ano    su_ano_his.cod_err_su_ano%TYPE := NULL;
    err_except          EXCEPTION;
    
    v_ret               VARCHAR2(100);
    v_duree_prep        NUMBER  := 0;
    v_duree_cumul       NUMBER  := 0;
    v_colis_cumul       NUMBER  := 0;
    v_cpt               NUMBER  := 0;
    v_nb_pal            NUMBER  := 0;
    v_nb_col_pal        NUMBER  := 0;
    v_rst_col           NUMBER  := 0;
    v_no_pal            NUMBER  := 1;
    v_tag_dat_maq_min   CHAR    := '0';
    v_dat_maq_min       DATE;

    r_pc_deb            tr_sp_pc_gph_deb;
    
    CURSOR  c_prep (x_dat_fin DATE) IS
    SELECT  ec.dat_exp,
            NULL cod_ut,
            NULL typ_ut,
            ec.no_com,
            SUM (lc.qte_cde) nb_col,
            0 nb_intercalaires, 
            ec.cod_usn
    FROM    pc_ent_com ec, pc_lig_com lc
    WHERE   lc.typ_lig_com = 'S'
    AND     lc.no_com  = ec.no_com
    AND     ec.cod_usn = p_cod_usn
    AND     su_bas_etat_val_num (ec.etat_atv_pc_ent_com, 'PC_ENT_COM') <
                su_bas_etat_val_num ('PRPP', 'PC_ENT_COM')
    AND     ec.dat_exp < x_dat_fin
    AND     EXISTS
                 (SELECT 1
                    FROM pc_lig_com lc2
                   WHERE lc2.no_com = ec.no_com
                     AND su_bas_etat_val_num (lc2.etat_atv_pc_lig_com, 'PC_LIG_COM') <
                             su_bas_etat_val_num ('ORDT', 'PC_LIG_COM'))
    AND (lc.libre_pc_lig_com_12 IS NULL OR lc.libre_pc_lig_com_12 IN ('0','3'))
    GROUP BY dat_exp, ec.no_com, ec.cod_usn
    UNION ALL
    SELECT  ec.dat_exp,
            ut.cod_ut,
            ut.typ_ut,
            ec.no_com,
            COUNT (*) nb_col,
            SUM (DECODE (NVL (uee.intercalaire, '#NULL#'), '#NULL#', 0, 1))
                nb_intercalaires, 
            ec.cod_usn
    FROM    pc_ut ut, pc_uee uee,
            pc_ent_com ec, pc_lig_com lc,
            pc_uee_det det
    WHERE   lc.typ_lig_com = 'S'
    AND     lc.no_com  = ec.no_com
    AND     ec.no_com = ut.no_com
    AND     ec.cod_usn = p_cod_usn
    AND     su_bas_etat_val_num (ec.etat_atv_pc_ent_com, 'PC_ENT_COM') <
                su_bas_etat_val_num ('PRPP', 'PC_ENT_COM')
    AND     uee.cod_ut_sup = ut.cod_ut
    AND     uee.typ_ut_sup = ut.typ_ut
    AND     uee.no_uee = det.no_uee
    AND     det.no_com = lc.no_com
    AND     det.no_lig_com = lc.no_lig_com
    AND     ut.dat_exp_ini < x_dat_fin
    AND     EXISTS
                 (SELECT 1
                    FROM pc_lig_com lc2
                   WHERE lc2.no_com = ec.no_com
                     AND su_bas_etat_val_num (lc2.etat_atv_pc_lig_com, 'PC_LIG_COM') >= su_bas_etat_val_num ('PORD', 'PC_LIG_COM')
                     AND su_bas_etat_val_num (lc2.etat_atv_pc_lig_com, 'PC_LIG_COM') < su_bas_etat_val_num ('ORDT', 'PC_LIG_COM'))
    AND (lc.libre_pc_lig_com_12 IS NULL OR lc.libre_pc_lig_com_12 IN ('0','3'))
    GROUP BY ec.dat_exp, ec.no_com, ut.cod_ut, ut.typ_ut, ec.cod_usn
    ORDER BY dat_exp;
       
    r_prep c_prep%ROWTYPE;
    
BEGIN
    v_etape := 'Trace';
    IF su_global_pkv.v_niv_dbg >= 3 THEN
        su_bas_put_debug(v_nom_obj||' - p_cod_usn : '||p_cod_usn
                                  ||' - p_dat_deb : '||to_char(p_dat_deb,'YYYYMMDD HH24:MI')
                                  ||' - p_dat_fin : '||to_char(p_dat_fin,'YYYYMMDD HH24:MI'));
    END IF;

    v_etape := 'Calcul des enregistrements';

    OPEN c_prep(p_dat_fin);
    LOOP
        FETCH c_prep INTO r_prep;
        EXIT WHEN c_prep%NOTFOUND;

        v_etape := 'Initialisatio de la date min maq moins 1 sec';
        IF v_tag_dat_maq_min = '0' THEN
            v_dat_maq_min     := r_prep.dat_exp-1/86400;
            v_tag_dat_maq_min := '1';
        END IF;

        v_etape := 'Traitement du cumul temps';    
        IF  r_prep.cod_ut IS NULL THEN
            v_etape := 'Traitement des commandes avant pré-ordo';
            v_nb_col_pal := su_bas_rch_par_usn( p_cod_par_usn   => 'SP_NB_COL_MOY_PAL',
                                                p_cod_usn       => p_cod_usn);
            v_nb_pal := TRUNC(r_prep.nb_col / v_nb_col_pal);

            v_rst_col := MOD(r_prep.nb_col, v_nb_col_pal);

            FOR v_cpt IN 1..v_nb_pal LOOP
                v_duree_prep := su_bas_to_number(su_bas_rch_action  (
                                                    p_nom_par       => 'SP_DUREE_PREP',
                                                    p_par           => v_nb_col_pal));
    
                v_duree_cumul := v_duree_cumul + v_duree_prep;
                v_colis_cumul := v_colis_cumul + v_nb_col_pal;

                r_pc_deb.num_pal    := v_no_pal;
                r_pc_deb.dat_prep   := p_dat_deb + v_duree_cumul/(24*60*60);
                r_pc_deb.delai_prep := v_duree_cumul;
                r_pc_deb.dat_maq    := r_prep.dat_exp;
                r_pc_deb.delai_maq  := (r_prep.dat_exp - p_dat_deb)*(24*60*60);
                r_pc_deb.nb_col     := v_nb_col_pal;
                r_pc_deb.tot_col    := v_colis_cumul;

                v_no_pal := v_no_pal + 1;

                v_etape := 'Ajout de la ligne';
                pipe ROW(r_pc_deb);

            END LOOP;

            IF v_rst_col > 0 THEN
                v_duree_prep := su_bas_to_number(su_bas_rch_action  (
                                                    p_nom_par       => 'SP_DUREE_PREP',
                                                    p_par           => v_rst_col));
    
                v_duree_cumul := v_duree_cumul + v_duree_prep;
                v_colis_cumul := v_colis_cumul + v_rst_col;

                r_pc_deb.num_pal    := v_no_pal;
                r_pc_deb.dat_prep   := p_dat_deb + v_duree_cumul/(24*60*60);
                r_pc_deb.delai_prep := v_duree_cumul;
                r_pc_deb.dat_maq    := r_prep.dat_exp;
                r_pc_deb.delai_maq  := (r_prep.dat_exp - p_dat_deb)*(24*60*60);
                r_pc_deb.nb_col     := v_rst_col;
                r_pc_deb.tot_col    := v_colis_cumul;

                v_no_pal := v_no_pal + 1;

                v_etape := 'Ajout de la ligne';
                pipe ROW(r_pc_deb);

            END IF;
    
        ELSE
            v_etape := 'Traitement des commandes apres pré-ordo et avant PRP0';
            v_duree_prep := su_bas_to_number(r_prep.nb_intercalaires)
                                * su_bas_to_number(su_bas_rch_action  (
                                                p_nom_par       => 'SP_DUREE_PREP',
                                                p_par           => 'I'))
                            + su_bas_to_number(su_bas_rch_action  (
                                            p_nom_par       => 'SP_DUREE_PREP',
                                            p_par           => r_prep.nb_col));

            v_duree_cumul := v_duree_cumul + v_duree_prep;
            v_colis_cumul := v_colis_cumul + r_prep.nb_col;

            r_pc_deb.num_pal    := v_no_pal;
            r_pc_deb.dat_prep   := p_dat_deb + v_duree_cumul/(24*60*60);
            r_pc_deb.delai_prep := v_duree_cumul;
            r_pc_deb.dat_maq    := r_prep.dat_exp;
            r_pc_deb.delai_maq  := (r_prep.dat_exp - p_dat_deb)*(24*60*60);
            r_pc_deb.nb_col     := r_prep.nb_col;
            r_pc_deb.tot_col    := v_colis_cumul;
    
            v_no_pal := v_no_pal + 1;

            v_etape := 'Ajout de la ligne';
            pipe ROW(r_pc_deb);
        END IF;        

        v_etape := 'Trace';
        IF su_global_pkv.v_niv_dbg >= 9 THEN
            su_bas_put_debug(v_nom_obj||' Pal : '||r_pc_deb.num_pal||
                                        ' - date prep : '||to_char(r_pc_deb.dat_prep, 'YYYYMMDD HH24:MI')||
                                        ' - delai prep  : '||r_pc_deb.delai_prep||
                                        ' - date maq  : '||to_char(r_pc_deb.dat_maq, 'YYYYMMDD HH24:MI')||
                                        ' - delai maq  : '||r_pc_deb.delai_maq||
                                        ' - nb col : '||r_pc_deb.nb_col||
                                        ' - tot col : '||r_pc_deb.tot_col);
        END IF;

    END LOOP;
    CLOSE c_prep;

    v_etape := 'Ajout dernier point';
    IF r_pc_deb.dat_prep < r_pc_deb.dat_maq THEN
        r_pc_deb.num_pal    := v_no_pal;
        r_pc_deb.dat_prep   := r_prep.dat_exp;
        r_pc_deb.delai_prep := NULL;
        r_pc_deb.dat_maq    := NULL;
        r_pc_deb.delai_maq  := NULL;
        r_pc_deb.nb_col     := 0;
        r_pc_deb.tot_col    := v_colis_cumul;
        v_etape := 'Ajout de la ligne';
        pipe ROW(r_pc_deb);
        
    END IF;

    v_etape := 'Ajout premier point';
    r_pc_deb.num_pal    := 0;
    r_pc_deb.dat_prep   := p_dat_deb;
    r_pc_deb.delai_prep := 0;
    r_pc_deb.dat_maq    := v_dat_maq_min; 
    r_pc_deb.delai_maq  := 0;
    r_pc_deb.nb_col     := 0;
    r_pc_deb.tot_col    := 0;
    v_etape := 'Ajout de la ligne';
    pipe ROW(r_pc_deb);

EXCEPTION
    WHEN NO_DATA_NEEDED THEN 
        NULL;
END;

-- DESCRIPTION :
-- -------------
-- Cette fonction permet le calcul de la date max de prépa
FUNCTION sp_pc_dat_max_prep_deb (p_cod_usn  su_usn.cod_usn%TYPE,
                                 p_dat_deb  DATE, 
                                 p_dat_fin  DATE)
     RETURN DATE
IS  
    v_version           su_ano_his.version%TYPE := '@(#) VERSION 01a $Revision$';
    v_nom_obj           su_ano_his.nom_obj%TYPE := 'sp_pc_dat_max_prep_deb';
    v_etape             su_ano_his.txt_ano%TYPE := 'Declare';
    v_cod_err_su_ano    su_ano_his.cod_err_su_ano%TYPE := NULL;
    err_except          EXCEPTION;

    CURSOR c_max_d_prep IS
	SELECT MAX (dat_prep) 
	FROM TABLE(sp_pc_gph_deb_to_tab (p_cod_usn, p_dat_deb, p_dat_fin));

    v_dat_max           DATE;
BEGIN
    OPEN c_max_d_prep;
	FETCH c_max_d_prep INTO v_dat_max;
    CLOSE c_max_d_prep;

    RETURN v_dat_max;

EXCEPTION
    WHEN OTHERS THEN 
        su_bas_cre_ano ( p_txt_ano         => 'EXCEPTION : ' || v_etape, 
                         p_cod_err_ora_ano => SQLCODE, 
                         p_lib_ano_1       => 'p_cod_usn ', 
                         p_par_ano_1       => p_cod_usn, 
                         p_lib_ano_2       => 'p_dat_deb ', 
                         p_par_ano_2       => p_dat_deb, 
                         p_lib_ano_3       => 'p_dat_fin ', 
                         p_par_ano_3       => p_dat_fin,  
                         p_cod_err_su_ano  => v_cod_err_su_ano, 
                         p_nom_obj         => v_nom_obj, 
                         p_version         => v_version ); 

END;

-- DESCRIPTION :
-- -------------
-- Fonction de calcul de la date de dépassement de capacité et du volume concerné
FUNCTION sp_pc_dat_qte_dep_deb (p_cod_usn           su_usn.cod_usn%TYPE,
                                p_dat_deb           DATE, 
                                p_dat_fin           DATE,
                                p_dat_dep       OUT DATE,
                                p_nb_col_dep    OUT NUMBER)
     RETURN VARCHAR2
IS    
    v_version           su_ano_his.version%TYPE := '@(#) VERSION 01a $Revision$';
    v_nom_obj           su_ano_his.nom_obj%TYPE := 'sp_pc_gph_prep_deb_to_tab';
    v_etape             su_ano_his.txt_ano%TYPE := 'Declare';
    v_cod_err_su_ano    su_ano_his.cod_err_su_ano%TYPE := NULL;
    err_except          EXCEPTION;

    v_ret               VARCHAR2(100) := 'OK';
    v_dat_dep           DATE;

    CURSOR c_dat_dep_cap IS
	SELECT MIN (dat_prep)
	FROM TABLE(sp_pc_gph_deb_to_tab (p_cod_usn, p_dat_deb, p_dat_fin))
    WHERE delai_maq < delai_prep;

    v_dat_max           DATE;

    -- calcul de l'ecart max entre dat_deb et dat_fin de la diff entre les 2 courbes
    CURSOR c_qte_dep_cap IS
    WITH d
    AS (SELECT dat_prep, dat_maq, tot_col FROM TABLE (sp_pc_gph_deb_to_tab (p_cod_usn,p_dat_deb,p_dat_fin)))
    SELECT MAX (qte_exp - qte_prep)
      FROM (  SELECT d1.dat_prep,
                     MIN (d1.tot_col) qte_prep,
                     MAX (d2.tot_col) qte_exp
                FROM d d1, d d2
               WHERE d1.dat_prep >=
                           d2.dat_maq
                         - (su_bas_to_number (
                                su_bas_rch_action ('FRM_SP_GES_DEBORD',
                                                   'DELAI_MAQ')))
            GROUP BY d1.dat_prep);

BEGIN
    OPEN c_dat_dep_cap;
	FETCH c_dat_dep_cap INTO p_dat_dep;
    CLOSE c_dat_dep_cap;

    OPEN c_qte_dep_cap;
	FETCH c_qte_dep_cap INTO p_nb_col_dep;
    CLOSE c_qte_dep_cap;

    RETURN v_ret;

EXCEPTION
    WHEN OTHERS THEN 
        su_bas_cre_ano ( p_txt_ano         => 'EXCEPTION : ' || v_etape, 
                         p_cod_err_ora_ano => SQLCODE, 
                         p_lib_ano_1       => 'p_cod_usn ', 
                         p_par_ano_1       => p_cod_usn, 
                         p_lib_ano_2       => 'p_dat_deb ', 
                         p_par_ano_2       => p_dat_deb, 
                         p_lib_ano_3       => 'p_dat_fin ', 
                         p_par_ano_3       => p_dat_fin,  
                         p_cod_err_su_ano  => v_cod_err_su_ano, 
                         p_nom_obj         => v_nom_obj, 
                         p_version         => v_version ); 
        IF (v_ret = 'OK' OR v_ret IS null OR v_ret = 'ERROR') THEN 
            RETURN (NVL (v_cod_err_su_ano, 'ERROR')); 
        ELSE 
            RETURN (v_ret); 
        END IF;
END;


-- DESCRIPTION :
-- -------------
-- Fonction de calcul des lignes commandes à passer en débord
FUNCTION sp_pc_cal_vol_deb (p_cod_usn su_usn.cod_usn%TYPE, p_dat_deb DATE, p_dat_fin DATE)
     RETURN VARCHAR2
IS
    v_version           su_ano_his.version%TYPE := '@(#) VERSION 01a $Revision$';
    v_nom_obj           su_ano_his.nom_obj%TYPE := 'sp_pc_cal_vol_deb';
    v_etape             su_ano_his.txt_ano%TYPE := 'Declare';
    v_cod_err_su_ano    su_ano_his.cod_err_su_ano%TYPE := NULL;
    err_except          EXCEPTION;

    v_ret               VARCHAR2(100) := 'OK';
    v_cod_cli           su_tiers.cod_tiers%TYPE := NULL;
    v_cod_groupe        pc_lig_com.cle_rgp_pal_1%TYPE := NULL;

    v_dat_dep           DATE;
    v_dat_deb_calcul    DATE;
    v_duree_max_calcul  NUMBER;
    v_qte_pal_std       NUMBER;
    v_tag_pro_tab       CHAR;
    v_nb_col_dep        NUMBER;
    v_cpt_volume        NUMBER := 0;
    v_cpt_deb           NUMBER := 0;
    v_cpt               NUMBER;
    v_stk_deb           tt_stk_deb;
    v_i                 NUMBER;

    -- Curseur principale sur les lignes restantes à analyser
    CURSOR c_lig_deb(x_cod_cli su_tiers.cod_tiers%TYPE, 
                     x_cod_groupe pc_lig_com.cle_rgp_pal_1%TYPE) IS
        SELECT no_com, no_lig_com, cod_pro, qte_cde, cod_cli, cle_rgp_pal_1
        FROM V_SP_DEB_COM_PRO_MAP
        WHERE cod_usn = p_cod_usn
        AND cod_pss_afc != 'SDB01' -- Process débord
        AND nvl(mod_deb,'0') IN ('0','3') -- libre_pc_lig_com_12
        AND nvl(lect_lig,'0') = '0' -- libre_pc_lig_com_13
        AND (x_cod_cli IS NULL OR cod_cli = x_cod_cli)
        AND (x_cod_groupe IS NULL OR cle_rgp_pal_1 = x_cod_groupe)
        --AND (p_dat_deb IS NULL OR dat_exp > p_dat_deb)
        AND (p_dat_fin IS NULL OR dat_exp <= p_dat_fin)
        ORDER BY 4 DESC;

   r_lig_deb    c_lig_deb%ROWTYPE;
   f_lig_deb    BOOLEAN;

    -- Curseur retournant si un produit est mappé
    CURSOR c_pro_map(x_cod_pro su_pro.cod_pro%TYPE) IS
        SELECT p.cod_pro 
        FROM su_pro p
        WHERE p.cod_pro = x_cod_pro
        AND p.LIBRE_SU_PRO_13 = '20' -- etat mapping
        AND EXISTS (SELECT 1 
                    FROM se_afc_emp a
                    WHERE a.cod_pro = p.cod_pro) ;

    r_pro_map   c_pro_map%ROWTYPE;
    f_pro_map   BOOLEAN;

    -- Curseur retournant si un produit est mappé
    CURSOR c_afc_emp(x_cod_pro su_pro.cod_pro%TYPE) IS
        SELECT 1
        FROM se_afc_emp
        WHERE cod_pro = x_cod_pro;

    r_afc_emp   c_afc_emp%ROWTYPE;
    f_afc_emp   BOOLEAN;

    -- Curseur produit pour mapping
    -- SI ON PREND TOUJOURS LE PREMIER PRODUIT ON RISQUE DE BOUCLER ET DE NE FAIRE QU'AJOUTER DE 
    -- LA QUANTITé SUR UNE REFERENCE QUI N'EN A PAS BESOIN
    CURSOR c_pro_pal_map IS
      SELECT p.cod_pro,
             COUNT (DISTINCT ue.cod_up) qte_pal,
             DECODE (NVL (a.no_afc_emp, 0), 0, '0', '1') etat_map
        FROM su_pro p,
             se_afc_emp a,
             pc_lig_com lc,
             pc_uee ue,
             pc_uee_det ud
       WHERE lc.cod_usn = su_global_pkg.su_bas_get_cod_usn
         AND lc.typ_lig_com = 'S'
         AND lc.no_com = ud.no_com
         AND lc.no_lig_com = ud.no_lig_com
         AND ud.no_uee = ue.no_uee
         AND su_bas_etat_val_num (lc.etat_atv_pc_lig_com, 'PC_LIG_COM') <
                 su_bas_etat_val_num ('ORDT', 'PC_LIG_COM')
         AND lc.cod_pss_afc != 'SDB01'
         AND lc.cod_pro = p.cod_pro
         AND p.cod_pro = a.cod_pro(+)
         AND p.libre_su_pro_13 = '20' -- Le produit doit être qualifié et implanté
         AND lc.lst_fct_lock IS NULL
         AND ue.cod_up IN
                 (SELECT DISTINCT ue2.cod_up
                    FROM pc_lig_com lc2, pc_uee ue2, pc_uee_det ud2
                   WHERE lc2.typ_lig_com = 'S'
                     AND lc2.cod_usn = su_global_pkg.su_bas_get_cod_usn
                     AND lc2.no_com = ud2.no_com
                     AND lc2.no_lig_com = ud2.no_lig_com
                     AND (lc2.libre_pc_lig_com_12 IN ('1', '2')
                       OR (su_bas_etat_val_num (lc2.etat_atv_pc_lig_com,
                                                'PC_LIG_COM') <
                               su_bas_etat_val_num ('ORDT', 'PC_LIG_COM')
                       AND lc2.cod_pss_afc = 'SDB01'))
                     AND ud2.no_uee = ue2.no_uee)        -- Recup des up impactées
         AND EXISTS
                     (SELECT 1
                        FROM pc_lig_com lc3
                       WHERE lc3.typ_lig_com = 'S'
                         AND su_bas_etat_val_num (lc3.etat_atv_pc_lig_com,
                                                  'PC_LIG_COM') <
                                 su_bas_etat_val_num ('ORDT', 'PC_LIG_COM')
                         AND lc3.libre_pc_lig_com_12 NOT IN ('1', '2')
                         AND lc3.cod_pss_afc != 'SDB01'
                         AND lc3.cod_pro = p.cod_pro) -- exclusion des produits sans lignes a traiter
    GROUP BY p.cod_pro, DECODE (NVL (a.no_afc_emp, 0), 0, '0', '1') 
    ORDER BY 2 DESC, 3 DESC;

    r_pro_pal_map   c_pro_pal_map%ROWTYPE;

    -- Curseur des quantité par produit dans le stk debord
    CURSOR c_pro_stk IS
        SELECT cod_pro, SUM(qte_dispo) qte
        FROM v_se_stk
        WHERE cod_vl = '10'
        AND cod_mag = 'SPD'
        GROUP BY cod_pro;

    r_pro_stk   c_pro_stk%ROWTYPE;
    f_pro_stk   BOOLEAN;

BEGIN

    v_etape := 'Dépose du savepoint sp_pc_cal_vol_deb';
    SAVEPOINT sp_pc_cal_vol_deb;

    v_etape := 'Trace';
    IF su_global_pkv.v_niv_dbg >= 3 THEN
        su_bas_put_debug(v_nom_obj||' - p_cod_usn : '||p_cod_usn
                                  ||' - p_dat_deb : '||to_char(p_dat_deb,'YYYYMMDD HH24:MI')
                                  ||' - p_dat_fin : '||to_char(p_dat_fin,'YYYYMMDD HH24:MI'));
    END IF;

    v_etape := 'Reinitialisation de la simu et mode debord';
    UPDATE pc_lig_com
    SET libre_pc_lig_com_12 = '0'
    WHERE etat_atv_pc_lig_com IN ('APSS','PORD')
    AND lst_fct_lock IS NULL;

    COMMIT;

    v_etape := 'Calcul du volume cible à passer en débord';
    v_ret := sp_pc_dat_qte_dep_deb (p_cod_usn       => p_cod_usn,
                                    p_dat_deb       => p_dat_deb,
                                    p_dat_fin       => p_dat_fin,
                                    p_dat_dep       => v_dat_dep,
                                    p_nb_col_dep    => v_nb_col_dep);

    IF su_global_pkv.v_niv_dbg >= 6 THEN
        su_bas_put_debug(v_nom_obj||' Il y a '||v_nb_col_dep||' colis à passer en débord');
    END IF;

    IF v_ret != 'OK' THEN
        RAISE err_except;
    END IF;

    v_etape := 'Création d''un tableau pour réservations dans stock débord';
    v_stk_deb.DELETE;
    v_i := 0;

    FOR r_tab_pro IN c_pro_stk LOOP
        v_stk_deb(v_i).cod_pro := r_tab_pro.cod_pro;
        v_stk_deb(v_i).qte := r_tab_pro.qte;
        v_i := v_i +1;
    END LOOP;

    IF su_global_pkv.v_niv_dbg >= 6 THEN
        su_bas_put_debug(v_nom_obj||' Il y a '||v_i||' produits en débord');
    END IF;
    
    -- Init de la durée max de calcul et de la date de début de calcul
    v_duree_max_calcul := su_bas_to_number(
                              su_bas_rch_action  (
                                  p_nom_par => 'FRM_SP_GES_DEBORD',
                                  p_par     => 'DELAI_CAL'));
    v_dat_deb_calcul := SYSDATE;

    v_etape := 'Boucle while';
    IF su_global_pkv.v_niv_dbg >= 8 THEN
        su_bas_put_debug(v_nom_obj||' - '||v_etape);
    END IF;
    <<boucle_generale>>
    WHILE TRUE LOOP
        v_etape := 'Sortie si le volume a été ventilé sur le débord';
        IF v_cpt_volume >= v_nb_col_dep THEN
            IF su_global_pkv.v_niv_dbg >= 9 THEN
                su_bas_put_debug(v_nom_obj||' - '||v_etape);
            END IF;

            EXIT boucle_generale;
        END IF;

        v_etape := 'Sortie si timer expiré';
        IF SYSDATE > v_dat_deb_calcul + (v_duree_max_calcul/86400) THEN
            IF su_global_pkv.v_niv_dbg >= 8 THEN
                su_bas_put_debug(v_nom_obj||' - '||v_etape);
            END IF;
    
            EXIT boucle_generale;
        END IF;
        
        v_etape := 'Sélection nouveau produit si toutes les lignées ont été lues';
        OPEN c_lig_deb(NULL, NULL);
        FETCH c_lig_deb INTO r_lig_deb;
        f_lig_deb := c_lig_deb%NOTFOUND;
        CLOSE c_lig_deb;

        IF f_lig_deb THEN
            IF su_global_pkv.v_niv_dbg >= 6 THEN
                su_bas_put_debug(v_nom_obj||' - '||v_etape);
            END IF;

            v_etape := 'Choix nouveau produit à mapper';
            OPEN c_pro_pal_map;
            FETCH c_pro_pal_map INTO r_pro_pal_map;

            IF c_pro_pal_map%found THEN
                v_etape := 'Init de variables pour mapping';

                IF su_global_pkv.v_niv_dbg >= 8 THEN
                    su_bas_put_debug(v_nom_obj||' - '||v_etape);
                END IF;

                v_qte_pal_std := su_bas_gcl_su_ul(
                                    p_cod_pro => r_pro_pal_map.cod_pro,
                                    p_cod_vl  => '10',
                                    p_colonne => 'NB_UL_PAL');
                v_tag_pro_tab := '0';

                v_etape := 'Si le produit existe dans le tableau de resa, maj qte';
                FOR v_i IN v_stk_deb.first..v_stk_deb.last LOOP
                    IF v_stk_deb(v_i).cod_pro = r_pro_pal_map.cod_pro THEN
                        v_stk_deb(v_i).qte := v_stk_deb(v_i).qte + v_qte_pal_std;
                        v_tag_pro_tab := '1';
                    END IF;
                END LOOP;

                v_etape := 'Creation du mapping produit'; 
                OPEN c_afc_emp(r_pro_pal_map.cod_pro);
                FETCH c_afc_emp INTO r_afc_emp;
                f_afc_emp := c_afc_emp%NOTFOUND;
                CLOSE c_afc_emp;

                IF f_afc_emp THEN

                    v_etape := 'Sortie si plus d''emplacement dispo';
                    v_ret := sp_pc_emp_disp_deb(p_cod_usn);
                    IF v_ret != 'OK' THEN
                        IF su_global_pkv.v_niv_dbg >= 8 THEN
                            su_bas_put_debug(v_nom_obj||' - '||v_etape);
                        END IF;
                
                        EXIT boucle_generale;
                    END IF;

                    v_etape := 'Creation de l''affectation emp';
                    v_ret := sp_pc_crea_mapping( p_cod_usn => p_cod_usn,
                                                 p_cod_pro => r_pro_pal_map.cod_pro);
                END IF;

                IF v_tag_pro_tab = '0' THEN           
                    v_etape := 'Ajouter produit dans tableau de resa';
                    v_cpt := v_stk_deb.last + 1;
                    v_stk_deb(v_cpt).cod_pro := r_pro_pal_map.cod_pro;
                    v_stk_deb(v_cpt).qte := v_qte_pal_std;
                END IF;

                IF su_global_pkv.v_niv_dbg >= 9 THEN
                    FOR v_i IN v_stk_deb.first..v_stk_deb.last LOOP
                        su_bas_put_debug(v_nom_obj||' - Tableau resa : '||v_i||' '|| v_stk_deb(v_i).cod_pro
                                                  ||' -> '||v_stk_deb(v_i).qte);
                    END LOOP;
                END IF;

                IF su_global_pkv.v_niv_dbg >= 6 THEN
                    su_bas_put_debug(v_nom_obj||' - Ajout mapping pro : '||r_pro_pal_map.cod_pro
                                              ||' - qte pal : '||v_qte_pal_std
                                              ||' - deja présent : '||v_tag_pro_tab);
                END IF;
            ELSE
                v_etape := 'Produit non trouvé';
                IF su_global_pkv.v_niv_dbg >= 8 THEN
                    su_bas_put_debug(v_nom_obj||' - '||v_etape);
                END IF;
        
                EXIT boucle_generale;
            END IF;

            CLOSE c_pro_pal_map;

            v_etape := 'Reinit de la lecture ligne';
            UPDATE pc_lig_com
            SET libre_pc_lig_com_13 = '0'
            WHERE libre_pc_lig_com_13 =  '1';

            -- Reinit des filtres
            v_cod_cli := NULL;
            v_cod_groupe := NULL;

        END IF;

        v_etape := 'Boucle lig com';
        IF su_global_pkv.v_niv_dbg >= 6 THEN
            su_bas_put_debug(v_nom_obj||' - '||v_etape
                                      ||' - v_cod_cli: '||v_cod_cli
                                      ||' - v_cod_groupe: '||v_cod_groupe);
        END IF;

        OPEN c_lig_deb(v_cod_cli, v_cod_groupe);
        <<boucle_lig_com>>
        LOOP
            FETCH c_lig_deb INTO r_lig_deb;
            
            -- Reinit des filtres
            v_cod_cli := NULL;
            v_cod_groupe := NULL;

            v_etape := 'Sortie de la boucle lig com';
            IF c_lig_deb%NOTFOUND THEN
                IF su_global_pkv.v_niv_dbg >= 8 THEN
                    su_bas_put_debug(v_nom_obj||' - '||v_etape);
                END IF;
    
                EXIT boucle_lig_com;
            END IF;

            v_etape := 'Toppage de la lecture de la ligne';
            IF su_global_pkv.v_niv_dbg >= 8 THEN
                su_bas_put_debug(v_nom_obj||' - '||v_etape||' - no_com.lig : '||r_lig_deb.no_com||'.'||r_lig_deb.no_lig_com);
            END IF;

            UPDATE pc_lig_com
            SET libre_pc_lig_com_13 = '1'
            WHERE no_com = r_lig_deb.no_com
            AND no_lig_com = r_lig_deb.no_lig_com;

            v_etape := 'Vérification du mapping produit';
            IF su_global_pkv.v_niv_dbg >= 8 THEN
                su_bas_put_debug(v_nom_obj||' - '||v_etape);
            END IF;

            OPEN c_pro_map(r_lig_deb.cod_pro);
            FETCH c_pro_map INTO r_pro_map;
            f_pro_map := c_pro_map%FOUND;
            CLOSE c_pro_map;

            IF f_pro_map THEN

                v_etape := 'Récupération de la quantité en stock';
                IF su_global_pkv.v_niv_dbg >= 8 THEN
                    su_bas_put_debug(v_nom_obj||' - '||v_etape||' - cod_pro : '||r_lig_deb.cod_pro);
                END IF;

                IF v_stk_deb.COUNT > 0 THEN
                    <<boucle_stk>>
                    FOR v_i IN v_stk_deb.first..v_stk_deb.last LOOP
                        IF v_stk_deb(v_i).cod_pro = r_lig_deb.cod_pro THEN
    
                            -- on parcours le tableau de qte par produit dans le débord
                            IF r_lig_deb.qte_cde <= nvl(v_stk_deb(v_i).qte, 0) THEN
    
                                v_etape := 'Quantité suffisante, toppage ligne à débord';
                                IF su_global_pkv.v_niv_dbg >= 8 THEN
                                    su_bas_put_debug(v_nom_obj||' - '||v_etape||' - cod_pro : '||r_lig_deb.cod_pro);
                                END IF;
    
                                UPDATE pc_lig_com
                                SET libre_pc_lig_com_12 = '1'
                                WHERE no_com = r_lig_deb.no_com
                                AND no_lig_com = r_lig_deb.no_lig_com;
    
                                v_etape := 'Incrémentation du volume total passé en débord et décrémentation du stock';
                                IF su_global_pkv.v_niv_dbg >= 9 THEN
                                    su_bas_put_debug(v_nom_obj||' - '||v_etape);
                                END IF;
                                v_cpt_volume := v_cpt_volume + r_lig_deb.qte_cde;
                                v_stk_deb(v_i).qte := v_stk_deb(v_i).qte - r_lig_deb.qte_cde;
    
                                v_etape := 'On positionne les variables du curseur pour le client et la cle de rgp';
                                IF su_global_pkv.v_niv_dbg >= 9 THEN
                                    su_bas_put_debug(v_nom_obj||' - '||v_etape);
                                END IF;
                                v_cod_cli := r_lig_deb.cod_cli;
                                v_cod_groupe := r_lig_deb.cle_rgp_pal_1;
    
                                EXIT boucle_lig_com; -- sortie de la première boucle et reouverture avec nouveau paramètre
                            END IF; -- si la quantité n'est pas suffisante on passe a la ligne suivante
                        END IF; -- si le produit n'est pas en débord on passe à la ligne suivante
                    END LOOP boucle_stk;
                END IF;
            END IF; -- sinon on passe à la ligne suivante
        END LOOP boucle_lig_com;
        CLOSE c_lig_deb;
    END LOOP boucle_generale;

    COMMIT;

    v_etape := 'Reinit de la lecture ligne';
    UPDATE pc_lig_com
    SET libre_pc_lig_com_13 = '0'
    WHERE libre_pc_lig_com_13 =  '1';

    COMMIT;

    RETURN v_ret;

EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK TO sp_pc_cal_vol_deb;
        su_bas_cre_ano ( p_txt_ano         => 'EXCEPTION : ' || v_etape, 
                         p_cod_err_ora_ano => SQLCODE, 
                         p_lib_ano_1       => 'p_cod_usn ', 
                         p_par_ano_1       => p_cod_usn, 
                         p_lib_ano_2       => 'p_dat_deb ', 
                         p_par_ano_2       => p_dat_deb, 
                         p_lib_ano_3       => 'p_dat_fin ', 
                         p_par_ano_3       => p_dat_fin,  
                         p_cod_err_su_ano  => v_cod_err_su_ano, 
                         p_nom_obj         => v_nom_obj, 
                         p_version         => v_version ); 
        IF (v_ret = 'OK' OR v_ret IS null OR v_ret = 'ERROR') THEN 
            RETURN (NVL (v_cod_err_su_ano, 'ERROR')); 
        ELSE 
            RETURN (v_ret); 
        END IF;
END;

-- DESCRIPTION :
-- -------------
-- Fonction de calcul de la place disponible pour mapping d'un nouveau produit en débord
FUNCTION sp_pc_emp_disp_deb (p_cod_usn     su_usn.cod_usn%TYPE)
     RETURN VARCHAR2
IS
    v_version           su_ano_his.version%TYPE := '@(#) VERSION 01a $Revision$';
    v_nom_obj           su_ano_his.nom_obj%TYPE := 'sp_pc_emp_disp_deb';
    v_etape             su_ano_his.txt_ano%TYPE := 'Declare';
    v_cod_err_su_ano    su_ano_his.cod_err_su_ano%TYPE := NULL;
    err_except          EXCEPTION;

    v_ret               VARCHAR2(100) := 'OK';

    CURSOR c_seuil_max IS
    SELECT   COUNT (*)
               * su_bas_to_number (
                      su_bas_rch_par_usn ('SP_TX_OQP_MAX_DEB', 'S'))
    FROM se_emp
    WHERE cod_mag = 'SPD';

    v_seuil_max NUMBER:=0;

    CURSOR c_ref_map IS
    SELECT SUM (NVL (a.qte_max, c.qte_max))
    FROM se_afc_emp a, se_cfg_rea c
    WHERE a.cod_mag = 'SPD' AND c.COD_CFG_REA = 'SP_BES_SUO';

    v_nb_ref_map   NUMBER := 0;

    CURSOR c_ref_a_map IS
    SELECT COUNT (DISTINCT cod_pro)
    FROM pc_lig_com
    WHERE libre_pc_lig_com_12 IN ('1','2')
    AND cod_pro NOT IN (SELECT cod_pro
                        FROM se_afc_emp
                        WHERE cod_mag = 'SPD');

    v_nb_ref_a_map NUMBER := 0;

BEGIN

    v_etape := 'Trace';
    IF su_global_pkv.v_niv_dbg >= 3 THEN
        su_bas_put_debug(v_nom_obj||' - p_cod_usn : '||p_cod_usn);
    END IF;

    v_etape := 'Calcul du seuil';
    OPEN c_seuil_max;
    FETCH c_seuil_max INTO v_seuil_max;
    CLOSE c_seuil_max;

    v_etape := 'Calcul du nombre de rérérences mappées';
    OPEN c_ref_map;
    FETCH c_ref_map INTO v_nb_ref_map;
    CLOSE c_ref_map;

    v_etape := 'Calcul du nombre de rérérences à mapper';
    OPEN c_ref_a_map;
    FETCH c_ref_a_map INTO v_nb_ref_a_map;
    CLOSE c_ref_a_map;

    IF (v_seuil_max < (v_nb_ref_map + v_nb_ref_a_map + 1 )) THEN
        v_etape := 'Le seuil est dépassé';
        v_ret := 'KO';
    END IF;

    RETURN v_ret;

EXCEPTION
    WHEN OTHERS THEN
        su_bas_cre_ano ( p_txt_ano         => 'EXCEPTION : ' || v_etape, 
                         p_cod_err_ora_ano => SQLCODE, 
                         p_lib_ano_1       => 'p_cod_usn ', 
                         p_par_ano_1       => p_cod_usn, 
                         p_cod_err_su_ano  => v_cod_err_su_ano, 
                         p_nom_obj         => v_nom_obj, 
                         p_version         => v_version ); 
        IF (v_ret = 'OK' OR v_ret IS null OR v_ret = 'ERROR') THEN 
            RETURN (NVL (v_cod_err_su_ano, 'ERROR')); 
        ELSE 
            RETURN (v_ret); 
        END IF;
END;

-- DESCRIPTION :
-- -------------
-- Fonction de validation de la selection de debord
FUNCTION sp_pc_crea_mapping (p_cod_usn      su_usn.cod_usn%TYPE,
                             p_cod_pro      su_pro.cod_pro%TYPE)
     RETURN VARCHAR2
IS
    v_version           su_ano_his.version%TYPE := '@(#) VERSION 01a $Revision$';
    v_nom_obj           su_ano_his.nom_obj%TYPE := 'sp_pc_crea_mapping';
    v_etape             su_ano_his.txt_ano%TYPE := 'Declare';
    v_cod_err_su_ano    su_ano_his.cod_err_su_ano%TYPE := NULL;
    err_except          EXCEPTION;

    v_ret               VARCHAR2(100) := 'OK';
    
    v_rec               se_afc_emp%ROWTYPE;
    v_rec2              se_afc_emp%ROWTYPE;

BEGIN
    v_etape := 'Trace';
    IF su_global_pkv.v_niv_dbg >= 3 THEN
        su_bas_put_debug(v_nom_obj||' - p_cod_usn : '||p_cod_usn);
    END IF;

    -- Creation du mapping si necessaire
    v_rec.typ_afc_emp := '00';
    v_rec.cod_usn := 'S';
    v_rec.cod_mag := 'SPD';
	v_rec.cod_va := '0';
	v_rec.cod_prk := '%';
	v_rec.cod_vl := '10';
	v_rec.no_ord_afc_emp := '1';
	v_rec.cod_cfg_rea := 'SP_BES_SUO';
	v_rec.typ_stk := '0';
	v_rec.lst_vl_rea := ';10;';
	v_rec.cod_pro := p_cod_pro;
	
	v_ret := se_bas_cre_afc_emp (v_rec);

    IF v_ret = 'OK' THEN
	   	v_rec2 := su_bas_grw_se_afc_emp (v_rec.no_afc_emp);
		v_ret := se_bas_synchro_stk_rea (v_rec2);

        IF v_ret != 'OK' THEN
            RAISE err_except;
        END IF;
    ELSE
        RAISE err_except;
	END IF;
	
    RETURN v_ret;
EXCEPTION
    WHEN OTHERS THEN
        su_bas_cre_ano ( p_txt_ano         => 'EXCEPTION : ' || v_etape, 
                         p_cod_err_ora_ano => SQLCODE, 
                         p_lib_ano_1       => 'p_cod_usn', 
                         p_par_ano_1       => p_cod_usn, 
                         p_lib_ano_2       => 'p_cod_pro', 
                         p_par_ano_2       => p_cod_pro, 
                         p_cod_err_su_ano  => v_cod_err_su_ano, 
                         p_nom_obj         => v_nom_obj, 
                         p_version         => v_version ); 
        IF (v_ret = 'OK' OR v_ret IS null OR v_ret = 'ERROR') THEN 
            RETURN (NVL (v_cod_err_su_ano, 'ERROR')); 
        ELSE 
            RETURN (v_ret); 
        END IF;
END;

-- DESCRIPTION :
-- -------------
-- Fonction de validation de la selection de debord
FUNCTION sp_pc_valid_selec_deb (p_cod_usn     su_usn.cod_usn%TYPE)
     RETURN VARCHAR2
IS
    v_version           su_ano_his.version%TYPE := '@(#) VERSION 01a $Revision$';
    v_nom_obj           su_ano_his.nom_obj%TYPE := 'sp_pc_valid_selec_deb';
    v_etape             su_ano_his.txt_ano%TYPE := 'Declare';
    v_cod_err_su_ano    su_ano_his.cod_err_su_ano%TYPE := NULL;
    err_except          EXCEPTION;

    v_ret               VARCHAR2(100) := 'OK';
    
    v_rec               se_afc_emp%ROWTYPE;
    v_rec2              se_afc_emp%ROWTYPE;

    CURSOR c_crea_mapping IS
	SELECT cod_pro
	  FROM V_SP_PRO_DEB 
	 WHERE etat_map = '0';
		 
	CURSOR c_xst_mapping(x_cod_pro su_pro.cod_pro%TYPE) IS
	SELECT cod_pro
	  FROM se_afc_emp
	 WHERE cod_mag = 'SPD'
	   AND cod_pro = x_cod_pro;

    r_xst_mapping c_xst_mapping%ROWTYPE;
	b_xst_mapping BOOLEAN;

BEGIN
    v_etape :=  'Depose d''un SAVEPOINT';
    SAVEPOINT sp_pc_valid_selec_deb;

    v_etape := 'Trace';
    IF su_global_pkv.v_niv_dbg >= 3 THEN
        su_bas_put_debug(v_nom_obj||' - p_cod_usn : '||p_cod_usn);
    END IF;
		   
    v_etape := 'Creation du mapping si necessaire';  
	FOR r_crea_mapping IN c_crea_mapping LOOP
		OPEN c_xst_mapping (r_crea_mapping.cod_pro);
		FETCH c_xst_mapping INTO r_xst_mapping;
		b_xst_mapping := c_xst_mapping%FOUND;
		CLOSE c_xst_mapping;
		
		IF NOT b_xst_mapping THEN
            v_ret := sp_pc_crea_mapping( p_cod_usn => p_cod_usn,
                                         p_cod_pro => r_crea_mapping.cod_pro);
		END IF;
	END LOOP;

    v_etape := 'Changement de process des lignes commandes';  
    v_ret := sp_pc_bas_chg_pss( p_cod_verrou    => 'DEB',
                                p_cod_pss		=> 'SDB01' ,
                                p_cod_atl		=> 'SPD');
                                --,p_no_uee		=> NULL);   
          
    IF v_ret != 'OK' THEN
        RAISE err_except;
    END IF;


    RETURN v_ret;

EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK TO sp_pc_valid_selec_deb;
        su_bas_cre_ano ( p_txt_ano         => 'EXCEPTION : ' || v_etape, 
                         p_cod_err_ora_ano => SQLCODE, 
                         p_lib_ano_1       => 'p_cod_usn', 
                         p_par_ano_1       => p_cod_usn, 
                         p_cod_err_su_ano  => v_cod_err_su_ano, 
                         p_nom_obj         => v_nom_obj, 
                         p_version         => v_version ); 
        IF (v_ret = 'OK' OR v_ret IS null OR v_ret = 'ERROR') THEN 
            RETURN (NVL (v_cod_err_su_ano, 'ERROR')); 
        ELSE 
            RETURN (v_ret); 
        END IF;
END;

-- DESCRIPTION :
-- -------------
-- Fonction de purge du stock de debord
FUNCTION sp_pc_purge_deb (p_cod_usn     su_usn.cod_usn%TYPE,
                          p_lst_cod_pro VARCHAR2)
     RETURN VARCHAR2
IS
    v_version           su_ano_his.version%TYPE := '@(#) VERSION 01a $Revision$';
    v_nom_obj           su_ano_his.nom_obj%TYPE := 'sp_pc_purge_deb';
    v_etape             su_ano_his.txt_ano%TYPE := 'Declare';
    v_cod_err_su_ano    su_ano_his.cod_err_su_ano%TYPE := NULL;
    err_except          EXCEPTION;

    v_ret               VARCHAR2(100) := 'OK';

    CURSOR c_cod_pro IS
        SELECT column_value cod_pro
          FROM TABLE(su_bas_lst_to_tab(p_lst_cod_pro));

    CURSOR c_ut_stk (x_cod_pro su_pro.cod_pro%TYPE) IS
        SELECT DISTINCT cod_ut, typ_ut
          FROM se_stk
         WHERE cod_pro = x_cod_pro
           AND cod_mag = 'SPD';

BEGIN
   v_etape := 'Trace';
    IF su_global_pkv.v_niv_dbg >= 3 THEN
        su_bas_put_debug(v_nom_obj||' - p_cod_usn : '||p_cod_usn);
    END IF;

    FOR r_cod_pro IN c_cod_pro LOOP

        v_etape := 'Suppression du mapping magasin';
        DELETE FROM se_afc_emp 
         WHERE cod_pro = r_cod_pro.cod_pro
           AND cod_mag = 'SPD'; 

        su_bas_commit;

        v_etape := 'Création des ordre de transfert';
        FOR r_ut_stk IN c_ut_stk(r_cod_pro.cod_pro) LOOP
            v_ret := 
                    se_bas_trf_stk (
                        p_typ_trf         => 'PURGE',
                        p_mode_trf        => 'DEM',
                        p_dat_mvt         => SYSDATE,
                        p_cod_fct_stk     => 'NEWORDTRF',
                        p_cod_raison      => 'PURGE',
                        p_motif_mvt       => 'PURGE_DEBORD',
                        p_cod_pro         => r_cod_pro.cod_pro,
                        p_cod_vl          => '10',
                        p_cod_va          => '0',
                        p_qte_trf         => 1,
                        p_unit_trf        => 'UT',
                        p_cod_usn         => su_global_pkv.v_cod_usn,
                        p_cod_mag         => 'SPD',
                        p_cod_ut          => r_ut_stk.cod_ut,
                        p_typ_ut          => r_ut_stk.typ_ut,
                        p_cod_usn_dest    => su_global_pkv.v_cod_usn,
                        p_cod_mag_dest    => 'SAA');

            IF v_ret != 'OK' THEN
                RAISE err_except;
            END IF;

            /*****************************************************************
            v_etape := 'Edition des etiquettes';
            *****************************************************************/

        END LOOP;
    END LOOP;

    RETURN v_ret;

EXCEPTION
    WHEN OTHERS THEN
        su_bas_cre_ano ( p_txt_ano         => 'EXCEPTION : ' || v_etape, 
                         p_cod_err_ora_ano => SQLCODE, 
                         p_lib_ano_1       => 'p_cod_usn ', 
                         p_par_ano_1       => p_cod_usn, 
                         p_lib_ano_2       => 'p_lst_cod_pro ', 
                         p_par_ano_2       => p_lst_cod_pro, 
                         p_cod_err_su_ano  => v_cod_err_su_ano, 
                         p_nom_obj         => v_nom_obj, 
                         p_version         => v_version ); 
        IF (v_ret = 'OK' OR v_ret IS null OR v_ret = 'ERROR') THEN 
            RETURN (NVL (v_cod_err_su_ano, 'ERROR')); 
        ELSE 
            RETURN (v_ret); 
        END IF;
END;

END; -- fin du package
/
show errors;

